# [字典序全排列算法研究](https://www.cnblogs.com/pmars/p/3458289.html)


【例】 一般而言，设P是[1,n]的一个全排列。
　　　　　　P=P1P2…Pn=P1P2…Pj-1PjPj+1…Pk-1PkPk+1…Pn
　　　　find:　　j=max{i|Pi<Pi+1}
　　　　　　　　　k=max{i|Pi>Pj}
　　　　　　1，  对换Pj，Pk，
　　　　　　2，  将Pj+1…Pk-1PjPk+1…Pn翻转
          P’= P1P2…Pj-1PkPn…Pk+1PjPk-1…Pj+1即P的下一个



【例】 如何得到346987521的下一个
    1，从尾部往前找第一个P(i-1) < P(i)的位置
4 6 <- 9 <- 8 <- 7 <- 5 <- 2 <- 1
        最终找到6是第一个变小的数字，记录下6的位置i-1
    2，从i位置往后找到最后一个大于6的数
4 6 -> 9 -> 8 -> 7 5 2 1
        最终找到7的位置，记录位置为m
    3，交换位置i-1和m的值
4 7 9 8 6 5 2 1
    4，倒序i位置后的所有数据
4 7 1 2 5 6 8 9
    则347125689为346987521的下一个排列

---
# 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

思路：位运算
两个数异或：相当于每一位相加，而不考虑进位；
两个数相与，并左移一位：相当于求得进位；
将上述两步的结果相加


```
public int Add(int num1,int num2) {
    while( num2!=0 ){
        int sum = num1 ^ num2;
        int carray = (num1 & num2) << 1;
        num1 = sum;
        num2 = carray;
    }
    return num1;
}
```


---